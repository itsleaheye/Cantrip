"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unflatten = void 0;
const utils_js_1 = require("./utils.js");
const globalObj = (typeof window !== "undefined"
    ? window
    : typeof globalThis !== "undefined"
        ? globalThis
        : undefined);
function unflatten(parsed) {
    const { hydrated, values } = this;
    if (typeof parsed === "number")
        return hydrate.call(this, parsed);
    if (!Array.isArray(parsed) || !parsed.length)
        throw new SyntaxError();
    const startIndex = values.length;
    values.push(...parsed);
    hydrated.length = values.length;
    return hydrate.call(this, startIndex);
}
exports.unflatten = unflatten;
function hydrate(index) {
    const { hydrated, values, deferred, plugins } = this;
    switch (index) {
        case utils_js_1.UNDEFINED:
            return;
        case utils_js_1.NULL:
            return null;
        case utils_js_1.NAN:
            return NaN;
        case utils_js_1.POSITIVE_INFINITY:
            return Infinity;
        case utils_js_1.NEGATIVE_INFINITY:
            return -Infinity;
        case utils_js_1.NEGATIVE_ZERO:
            return -0;
    }
    if (hydrated[index])
        return hydrated[index];
    const value = values[index];
    if (!value || typeof value !== "object")
        return (hydrated[index] = value);
    if (Array.isArray(value)) {
        if (typeof value[0] === "string") {
            const [type, b, c] = value;
            switch (type) {
                case utils_js_1.TYPE_DATE:
                    return (hydrated[index] = new Date(b));
                case utils_js_1.TYPE_URL:
                    return (hydrated[index] = new URL(b));
                case utils_js_1.TYPE_BIGINT:
                    return (hydrated[index] = BigInt(b));
                case utils_js_1.TYPE_REGEXP:
                    return (hydrated[index] = new RegExp(b, c));
                case utils_js_1.TYPE_SYMBOL:
                    return (hydrated[index] = Symbol.for(b));
                case utils_js_1.TYPE_SET:
                    const set = new Set();
                    hydrated[index] = set;
                    for (let i = 1; i < value.length; i++)
                        set.add(hydrate.call(this, value[i]));
                    return set;
                case utils_js_1.TYPE_MAP:
                    const map = new Map();
                    hydrated[index] = map;
                    for (let i = 1; i < value.length; i += 2) {
                        map.set(hydrate.call(this, value[i]), hydrate.call(this, value[i + 1]));
                    }
                    return map;
                case utils_js_1.TYPE_NULL_OBJECT:
                    const obj = Object.create(null);
                    hydrated[index] = obj;
                    for (const key in b)
                        obj[hydrate.call(this, Number(key))] = hydrate.call(this, b[key]);
                    return obj;
                case utils_js_1.TYPE_PROMISE:
                    if (hydrated[b]) {
                        return (hydrated[index] = hydrated[b]);
                    }
                    else {
                        const d = new utils_js_1.Deferred();
                        deferred[b] = d;
                        return (hydrated[index] = d.promise);
                    }
                case utils_js_1.TYPE_ERROR:
                    const [, message, errorType] = value;
                    let error = errorType && globalObj && globalObj[errorType]
                        ? new globalObj[errorType](message)
                        : new Error(message);
                    hydrated[index] = error;
                    return error;
                default:
                    // Run plugins at the end so we have a chance to resolve primitives
                    // without running into a loop
                    if (Array.isArray(plugins)) {
                        const args = value.slice(1).map((i) => hydrate.call(this, i));
                        for (const plugin of plugins) {
                            const result = plugin(value[0], ...args);
                            if (result)
                                return (hydrated[index] = result.value);
                        }
                    }
                    throw new SyntaxError();
            }
        }
        else {
            const array = [];
            hydrated[index] = array;
            for (let i = 0; i < value.length; i++) {
                const n = value[i];
                if (n !== utils_js_1.HOLE)
                    array[i] = hydrate.call(this, n);
            }
            return array;
        }
    }
    else {
        const object = {};
        hydrated[index] = object;
        for (const key in value) {
            object[hydrate.call(this, Number(key))] = hydrate.call(this, value[key]);
        }
        return object;
    }
}
