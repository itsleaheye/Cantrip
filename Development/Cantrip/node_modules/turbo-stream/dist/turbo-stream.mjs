// src/utils.ts
var HOLE = -1;
var NAN = -2;
var NEGATIVE_INFINITY = -3;
var NEGATIVE_ZERO = -4;
var NULL = -5;
var POSITIVE_INFINITY = -6;
var UNDEFINED = -7;
var TYPE_BIGINT = "B";
var TYPE_DATE = "D";
var TYPE_ERROR = "E";
var TYPE_MAP = "M";
var TYPE_NULL_OBJECT = "N";
var TYPE_PROMISE = "P";
var TYPE_REGEXP = "R";
var TYPE_SET = "S";
var TYPE_SYMBOL = "Y";
var TYPE_URL = "U";
var Deferred = class {
  promise;
  resolve;
  reject;
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
function createLineSplittingTransform() {
  const decoder = new TextDecoder();
  let leftover = "";
  return new TransformStream({
    transform(chunk, controller) {
      const str = decoder.decode(chunk, { stream: true });
      const parts = (leftover + str).split("\n");
      leftover = parts.pop() || "";
      for (const part of parts) {
        controller.enqueue(part);
      }
    },
    flush(controller) {
      if (leftover) {
        controller.enqueue(leftover);
      }
    }
  });
}

// src/flatten.ts
function flatten(input) {
  const { indices } = this;
  const existing = indices.get(input);
  if (existing)
    return existing;
  if (input === void 0)
    return UNDEFINED;
  if (input === null)
    return NULL;
  if (Number.isNaN(input))
    return NAN;
  if (input === Number.POSITIVE_INFINITY)
    return POSITIVE_INFINITY;
  if (input === Number.NEGATIVE_INFINITY)
    return NEGATIVE_INFINITY;
  if (input === 0 && 1 / input < 0)
    return NEGATIVE_ZERO;
  const index = this.index++;
  indices.set(input, index);
  stringify.call(this, input, index);
  return index;
}
function stringify(input, index) {
  const { deferred, plugins } = this;
  const str = this.stringified;
  const partsForObj = (obj) => Object.keys(obj).map((k) => `"${flatten.call(this, k)}":${flatten.call(this, obj[k])}`).join(",");
  switch (typeof input) {
    case "boolean":
    case "number":
    case "string":
      str[index] = JSON.stringify(input);
      break;
    case "bigint":
      str[index] = `["${TYPE_BIGINT}","${input}"]`;
      break;
    case "symbol": {
      const keyFor = Symbol.keyFor(input);
      if (!keyFor)
        throw new Error(
          "Cannot encode symbol unless created with Symbol.for()"
        );
      str[index] = `["${TYPE_SYMBOL}",${JSON.stringify(keyFor)}]`;
      break;
    }
    case "object": {
      if (!input) {
        str[index] = `${NULL}`;
        break;
      }
      const isArray = Array.isArray(input);
      let pluginHandled = false;
      if (!isArray && plugins) {
        for (const plugin of plugins) {
          const pluginResult = plugin(input);
          if (Array.isArray(pluginResult)) {
            pluginHandled = true;
            const [pluginIdentifier, ...rest] = pluginResult;
            str[index] = `[${JSON.stringify(pluginIdentifier)}`;
            if (rest.length > 0) {
              str[index] += `,${rest.map((v) => flatten.call(this, v)).join(",")}`;
            }
            str[index] += "]";
            break;
          }
        }
      }
      if (!pluginHandled) {
        let result = isArray ? "[" : "{";
        if (isArray) {
          for (let i = 0; i < input.length; i++)
            result += (i ? "," : "") + (i in input ? flatten.call(this, input[i]) : HOLE);
          str[index] = `${result}]`;
        } else if (input instanceof Date) {
          str[index] = `["${TYPE_DATE}",${input.getTime()}]`;
        } else if (input instanceof URL) {
          str[index] = `["${TYPE_URL}",${JSON.stringify(input.href)}]`;
        } else if (input instanceof RegExp) {
          str[index] = `["${TYPE_REGEXP}",${JSON.stringify(
            input.source
          )},${JSON.stringify(input.flags)}]`;
        } else if (input instanceof Set) {
          str[index] = `["${TYPE_SET}",${[...input].map((val) => flatten.call(this, val)).join(",")}]`;
        } else if (input instanceof Map) {
          str[index] = `["${TYPE_MAP}",${[...input].flatMap(([k, v]) => [flatten.call(this, k), flatten.call(this, v)]).join(",")}]`;
        } else if (input instanceof Promise) {
          str[index] = `["${TYPE_PROMISE}",${index}]`;
          deferred[index] = input;
        } else if (input instanceof Error) {
          str[index] = `["${TYPE_ERROR}",${JSON.stringify(input.message)}`;
          if (input.name !== "Error") {
            str[index] += `,${JSON.stringify(input.name)}`;
          }
          str[index] += "]";
        } else if (Object.getPrototypeOf(input) === null) {
          str[index] = `["${TYPE_NULL_OBJECT}",{${partsForObj(input)}}]`;
        } else if (isPlainObject(input)) {
          str[index] = `{${partsForObj(input)}}`;
        } else {
          throw new Error("Cannot encode object with prototype");
        }
      }
      break;
    }
    default:
      throw new Error("Cannot encode function or unexpected type");
  }
}
var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function isPlainObject(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === objectProtoNames;
}

// src/unflatten.ts
var globalObj = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : void 0;
function unflatten(parsed) {
  const { hydrated, values } = this;
  if (typeof parsed === "number")
    return hydrate.call(this, parsed);
  if (!Array.isArray(parsed) || !parsed.length)
    throw new SyntaxError();
  const startIndex = values.length;
  values.push(...parsed);
  hydrated.length = values.length;
  return hydrate.call(this, startIndex);
}
function hydrate(index) {
  const { hydrated, values, deferred, plugins } = this;
  switch (index) {
    case UNDEFINED:
      return;
    case NULL:
      return null;
    case NAN:
      return NaN;
    case POSITIVE_INFINITY:
      return Infinity;
    case NEGATIVE_INFINITY:
      return -Infinity;
    case NEGATIVE_ZERO:
      return -0;
  }
  if (hydrated[index])
    return hydrated[index];
  const value = values[index];
  if (!value || typeof value !== "object")
    return hydrated[index] = value;
  if (Array.isArray(value)) {
    if (typeof value[0] === "string") {
      const [type, b, c] = value;
      switch (type) {
        case TYPE_DATE:
          return hydrated[index] = new Date(b);
        case TYPE_URL:
          return hydrated[index] = new URL(b);
        case TYPE_BIGINT:
          return hydrated[index] = BigInt(b);
        case TYPE_REGEXP:
          return hydrated[index] = new RegExp(b, c);
        case TYPE_SYMBOL:
          return hydrated[index] = Symbol.for(b);
        case TYPE_SET:
          const set = /* @__PURE__ */ new Set();
          hydrated[index] = set;
          for (let i = 1; i < value.length; i++)
            set.add(hydrate.call(this, value[i]));
          return set;
        case TYPE_MAP:
          const map = /* @__PURE__ */ new Map();
          hydrated[index] = map;
          for (let i = 1; i < value.length; i += 2) {
            map.set(
              hydrate.call(this, value[i]),
              hydrate.call(this, value[i + 1])
            );
          }
          return map;
        case TYPE_NULL_OBJECT:
          const obj = /* @__PURE__ */ Object.create(null);
          hydrated[index] = obj;
          for (const key in b)
            obj[hydrate.call(this, Number(key))] = hydrate.call(this, b[key]);
          return obj;
        case TYPE_PROMISE:
          if (hydrated[b]) {
            return hydrated[index] = hydrated[b];
          } else {
            const d = new Deferred();
            deferred[b] = d;
            return hydrated[index] = d.promise;
          }
        case TYPE_ERROR:
          const [, message, errorType] = value;
          let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);
          hydrated[index] = error;
          return error;
        default:
          if (Array.isArray(plugins)) {
            const args = value.slice(1).map((i) => hydrate.call(this, i));
            for (const plugin of plugins) {
              const result = plugin(value[0], ...args);
              if (result)
                return hydrated[index] = result.value;
            }
          }
          throw new SyntaxError();
      }
    } else {
      const array = [];
      hydrated[index] = array;
      for (let i = 0; i < value.length; i++) {
        const n = value[i];
        if (n !== HOLE)
          array[i] = hydrate.call(this, n);
      }
      return array;
    }
  } else {
    const object = {};
    hydrated[index] = object;
    for (const key in value) {
      object[hydrate.call(this, Number(key))] = hydrate.call(
        this,
        value[key]
      );
    }
    return object;
  }
}

// src/turbo-stream.ts
async function decode(readable, options) {
  const { plugins } = options ?? {};
  const done = new Deferred();
  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();
  const decoder = {
    values: [],
    hydrated: [],
    deferred: {},
    plugins
  };
  const decoded = await decodeInitial.call(decoder, reader);
  let donePromise = done.promise;
  if (decoded.done) {
    done.resolve();
  } else {
    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {
      for (const deferred of Object.values(decoder.deferred)) {
        deferred.reject(reason);
      }
      done.reject(reason);
    });
  }
  return {
    done: donePromise.then(() => reader.closed),
    value: decoded.value
  };
}
async function decodeInitial(reader) {
  const read = await reader.read();
  if (!read.value) {
    throw new SyntaxError();
  }
  let line;
  try {
    line = JSON.parse(read.value);
  } catch (reason) {
    throw new SyntaxError();
  }
  return {
    done: read.done,
    value: unflatten.call(this, line)
  };
}
async function decodeDeferred(reader) {
  let read = await reader.read();
  while (!read.done) {
    if (!read.value)
      continue;
    const line = read.value;
    switch (line[0]) {
      case TYPE_PROMISE: {
        const colonIndex = line.indexOf(":");
        const deferredId = Number(line.slice(1, colonIndex));
        const deferred = this.deferred[deferredId];
        if (!deferred) {
          throw new Error(`Deferred ID ${deferredId} not found in stream`);
        }
        const lineData = line.slice(colonIndex + 1);
        let jsonLine;
        try {
          jsonLine = JSON.parse(lineData);
        } catch (reason) {
          throw new SyntaxError();
        }
        const value = unflatten.call(this, jsonLine);
        deferred.resolve(value);
        break;
      }
      case TYPE_ERROR: {
        const colonIndex = line.indexOf(":");
        const deferredId = Number(line.slice(1, colonIndex));
        const deferred = this.deferred[deferredId];
        if (!deferred) {
          throw new Error(`Deferred ID ${deferredId} not found in stream`);
        }
        const lineData = line.slice(colonIndex + 1);
        let jsonLine;
        try {
          jsonLine = JSON.parse(lineData);
        } catch (reason) {
          throw new SyntaxError();
        }
        const value = unflatten.call(this, jsonLine);
        deferred.reject(value);
        break;
      }
      default:
        throw new SyntaxError();
    }
    read = await reader.read();
  }
}
function encode(input, options) {
  const { plugins, signal } = options ?? {};
  const encoder = {
    deferred: {},
    index: 0,
    indices: /* @__PURE__ */ new Map(),
    stringified: [],
    plugins,
    signal
  };
  const textEncoder = new TextEncoder();
  let lastSentIndex = 0;
  const readable = new ReadableStream({
    async start(controller) {
      const id = flatten.call(encoder, input);
      if (id < 0) {
        controller.enqueue(textEncoder.encode(`${id}
`));
      } else {
        controller.enqueue(
          textEncoder.encode(`[${encoder.stringified.join(",")}]
`)
        );
        lastSentIndex = encoder.stringified.length - 1;
      }
      const seenPromises = /* @__PURE__ */ new WeakSet();
      while (Object.keys(encoder.deferred).length > 0) {
        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {
          if (seenPromises.has(deferred))
            continue;
          seenPromises.add(
            encoder.deferred[Number(deferredId)] = raceSignal(
              deferred,
              encoder.signal
            ).then(
              (resolved) => {
                const id2 = flatten.call(encoder, resolved);
                if (id2 < 0) {
                  controller.enqueue(
                    textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}
`)
                  );
                } else {
                  const values = encoder.stringified.slice(lastSentIndex + 1).join(",");
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_PROMISE}${deferredId}:[${values}]
`
                    )
                  );
                  lastSentIndex = encoder.stringified.length - 1;
                }
              },
              (reason) => {
                if (!reason || typeof reason !== "object" || !(reason instanceof Error)) {
                  reason = new Error("An unknown error occurred");
                }
                const id2 = flatten.call(encoder, reason);
                if (id2 < 0) {
                  controller.enqueue(
                    textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}
`)
                  );
                } else {
                  const values = encoder.stringified.slice(lastSentIndex + 1).join(",");
                  controller.enqueue(
                    textEncoder.encode(
                      `${TYPE_ERROR}${deferredId}:[${values}]
`
                    )
                  );
                  lastSentIndex = encoder.stringified.length - 1;
                }
              }
            ).finally(() => {
              delete encoder.deferred[Number(deferredId)];
            })
          );
        }
        await Promise.race(Object.values(encoder.deferred));
      }
      await Promise.all(Object.values(encoder.deferred));
      controller.close();
    }
  });
  return readable;
}
function raceSignal(promise, signal) {
  if (!signal)
    return promise;
  if (signal.aborted)
    return Promise.reject(signal.reason || new Error("Signal was aborted."));
  const abort = new Promise((resolve, reject) => {
    signal.addEventListener("abort", (event) => {
      reject(signal.reason || new Error("Signal was aborted."));
    });
    promise.then(resolve).catch(reject);
  });
  abort.catch(() => {
  });
  return Promise.race([abort, promise]);
}
export {
  decode,
  encode
};
