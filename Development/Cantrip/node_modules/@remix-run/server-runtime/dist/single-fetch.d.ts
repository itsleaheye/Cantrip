import type { ActionFunctionArgs as RRActionArgs, LoaderFunctionArgs as RRLoaderArgs, StaticHandler, unstable_DataStrategyFunction as DataStrategyFunction, StaticHandlerContext } from "@remix-run/router";
import type { AppLoadContext } from "./data";
import { ServerMode } from "./mode";
import type { TypedDeferredData, TypedResponse } from "./responses";
import type { SerializeFrom } from "./serialize";
export declare const SingleFetchRedirectSymbol: unique symbol;
type SingleFetchRedirectResult = {
    redirect: string;
    status: number;
    revalidate: boolean;
    reload: boolean;
};
export type SingleFetchResult = {
    data: unknown;
} | {
    error: unknown;
} | SingleFetchRedirectResult;
export type SingleFetchResults = {
    [key: string]: SingleFetchResult;
    [SingleFetchRedirectSymbol]?: SingleFetchRedirectResult;
};
export type DataStrategyCtx = {
    response: ResponseStub;
};
export declare function getSingleFetchDataStrategy(responseStubs: ReturnType<typeof getResponseStubs>, { isActionDataRequest, loadRouteIds, }?: {
    isActionDataRequest?: boolean;
    loadRouteIds?: string[];
}): DataStrategyFunction;
export declare function getSingleFetchResourceRouteDataStrategy({ responseStubs, }: {
    responseStubs: ReturnType<typeof getResponseStubs>;
}): DataStrategyFunction;
export declare function singleFetchAction(serverMode: ServerMode, staticHandler: StaticHandler, request: Request, handlerUrl: URL, loadContext: AppLoadContext, handleError: (err: unknown) => void): Promise<{
    result: SingleFetchResult;
    headers: Headers;
    status: number;
}>;
export declare function singleFetchLoaders(serverMode: ServerMode, staticHandler: StaticHandler, request: Request, handlerUrl: URL, loadContext: AppLoadContext, handleError: (err: unknown) => void): Promise<{
    result: SingleFetchResults;
    headers: Headers;
    status: number;
}>;
export declare function isResponseStub(value: any): value is ResponseStubImpl;
export declare function getResponseStubs(): Record<string | symbol, ResponseStubImpl>;
export declare function mergeResponseStubs(context: StaticHandlerContext, responseStubs: ReturnType<typeof getResponseStubs>, { isActionDataRequest }?: {
    isActionDataRequest?: boolean;
}): {
    statusCode: number;
    headers: Headers;
};
export declare function getSingleFetchRedirect(status: number, headers: Headers): SingleFetchRedirectResult;
export declare function encodeViaTurboStream(data: any, requestSignal: AbortSignal, streamTimeout: number | undefined, serverMode: ServerMode): ReadableStream<Uint8Array>;
type MaybePromise<T> = T | Promise<T>;
type Serializable = undefined | null | boolean | string | symbol | number | Array<Serializable> | {
    [key: PropertyKey]: Serializable;
} | bigint | Date | URL | RegExp | Error | Map<Serializable, Serializable> | Set<Serializable> | Promise<Serializable>;
type DataFunctionReturnValue = Serializable | TypedDeferredData<Record<string, unknown>> | TypedResponse<Record<string, unknown>>;
export type Serialize<T extends Loader | Action> = Awaited<ReturnType<T>> extends TypedDeferredData<infer D> ? D : Awaited<ReturnType<T>> extends TypedResponse<Record<string, unknown>> ? SerializeFrom<T> : Awaited<ReturnType<T>>;
export declare const ResponseStubOperationsSymbol: unique symbol;
export type ResponseStubOperation = [
    "set" | "append" | "delete",
    string,
    string?
];
/**
 * A stubbed response to let you set the status/headers of your response from
 * loader/action functions
 */
export type ResponseStub = {
    status: number | undefined;
    headers: Headers;
};
export type ResponseStubImpl = ResponseStub & {
    [ResponseStubOperationsSymbol]: ResponseStubOperation[];
};
type LoaderArgs = RRLoaderArgs<AppLoadContext> & {
    context: AppLoadContext;
    response: ResponseStub;
};
export type Loader = (args: LoaderArgs) => MaybePromise<DataFunctionReturnValue>;
export declare let defineLoader: <T extends Loader>(loader: T) => T;
type ActionArgs = RRActionArgs<AppLoadContext> & {
    context: AppLoadContext;
    response: ResponseStub;
};
export type Action = (args: ActionArgs) => MaybePromise<DataFunctionReturnValue>;
export declare let defineAction: <T extends Action>(action: T) => T;
export {};
